#include "matter_esp32_crypt.h"
#include "matter_protocol.h"

#define TT_CONTEXT_INIT "Matter PAKE V1 Commissioning"

#define PIN 12345670
#define RANDOM ((uint8_t *)"0123456789abcdefghijklmnopqrstuv")
#define SALT ((uint8_t *)"0123456789abcdef")
#define HMAC_ITER 1000

const uint8_t kDACert[] = {
    0x30, 0x82, 0x02, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
    0x01, 0x07, 0x02, 0xa0, 0x82, 0x02, 0x08, 0x30, 0x82, 0x02, 0x04, 0x02,
    0x01, 0x03, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
    0x65, 0x03, 0x04, 0x02, 0x01, 0x30, 0x82, 0x01, 0x70, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01, 0xa0, 0x82, 0x01, 0x61,
    0x04, 0x82, 0x01, 0x5d, 0x15, 0x24, 0x00, 0x01, 0x25, 0x01, 0xf1, 0xff,
    0x36, 0x02, 0x05, 0x00, 0x80, 0x05, 0x01, 0x80, 0x05, 0x02, 0x80, 0x05,
    0x03, 0x80, 0x05, 0x04, 0x80, 0x05, 0x05, 0x80, 0x05, 0x06, 0x80, 0x05,
    0x07, 0x80, 0x05, 0x08, 0x80, 0x05, 0x09, 0x80, 0x05, 0x0a, 0x80, 0x05,
    0x0b, 0x80, 0x05, 0x0c, 0x80, 0x05, 0x0d, 0x80, 0x05, 0x0e, 0x80, 0x05,
    0x0f, 0x80, 0x05, 0x10, 0x80, 0x05, 0x11, 0x80, 0x05, 0x12, 0x80, 0x05,
    0x13, 0x80, 0x05, 0x14, 0x80, 0x05, 0x15, 0x80, 0x05, 0x16, 0x80, 0x05,
    0x17, 0x80, 0x05, 0x18, 0x80, 0x05, 0x19, 0x80, 0x05, 0x1a, 0x80, 0x05,
    0x1b, 0x80, 0x05, 0x1c, 0x80, 0x05, 0x1d, 0x80, 0x05, 0x1e, 0x80, 0x05,
    0x1f, 0x80, 0x05, 0x20, 0x80, 0x05, 0x21, 0x80, 0x05, 0x22, 0x80, 0x05,
    0x23, 0x80, 0x05, 0x24, 0x80, 0x05, 0x25, 0x80, 0x05, 0x26, 0x80, 0x05,
    0x27, 0x80, 0x05, 0x28, 0x80, 0x05, 0x29, 0x80, 0x05, 0x2a, 0x80, 0x05,
    0x2b, 0x80, 0x05, 0x2c, 0x80, 0x05, 0x2d, 0x80, 0x05, 0x2e, 0x80, 0x05,
    0x2f, 0x80, 0x05, 0x30, 0x80, 0x05, 0x31, 0x80, 0x05, 0x32, 0x80, 0x05,
    0x33, 0x80, 0x05, 0x34, 0x80, 0x05, 0x35, 0x80, 0x05, 0x36, 0x80, 0x05,
    0x37, 0x80, 0x05, 0x38, 0x80, 0x05, 0x39, 0x80, 0x05, 0x3a, 0x80, 0x05,
    0x3b, 0x80, 0x05, 0x3c, 0x80, 0x05, 0x3d, 0x80, 0x05, 0x3e, 0x80, 0x05,
    0x3f, 0x80, 0x05, 0x40, 0x80, 0x05, 0x41, 0x80, 0x05, 0x42, 0x80, 0x05,
    0x43, 0x80, 0x05, 0x44, 0x80, 0x05, 0x45, 0x80, 0x05, 0x46, 0x80, 0x05,
    0x47, 0x80, 0x05, 0x48, 0x80, 0x05, 0x49, 0x80, 0x05, 0x4a, 0x80, 0x05,
    0x4b, 0x80, 0x05, 0x4c, 0x80, 0x05, 0x4d, 0x80, 0x05, 0x4e, 0x80, 0x05,
    0x4f, 0x80, 0x05, 0x50, 0x80, 0x05, 0x51, 0x80, 0x05, 0x52, 0x80, 0x05,
    0x53, 0x80, 0x05, 0x54, 0x80, 0x05, 0x55, 0x80, 0x05, 0x56, 0x80, 0x05,
    0x57, 0x80, 0x05, 0x58, 0x80, 0x05, 0x59, 0x80, 0x05, 0x5a, 0x80, 0x05,
    0x5b, 0x80, 0x05, 0x5c, 0x80, 0x05, 0x5d, 0x80, 0x05, 0x5e, 0x80, 0x05,
    0x5f, 0x80, 0x05, 0x60, 0x80, 0x05, 0x61, 0x80, 0x05, 0x62, 0x80, 0x05,
    0x63, 0x80, 0x18, 0x24, 0x03, 0x16, 0x2c, 0x04, 0x13, 0x43, 0x53, 0x41,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x53, 0x57, 0x43, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x2d, 0x30, 0x30, 0x24, 0x05, 0x00, 0x24, 0x06, 0x00, 0x24, 0x07,
    0x01, 0x24, 0x08, 0x00, 0x18, 0x31, 0x7c, 0x30, 0x7a, 0x02, 0x01, 0x03,
    0x80, 0x14, 0xfe, 0x34, 0x3f, 0x95, 0x99, 0x47, 0x76, 0x3b, 0x61, 0xee,
    0x45, 0x39, 0x13, 0x13, 0x38, 0x49, 0x4f, 0xe6, 0x7d, 0x8e, 0x30, 0x0b,
    0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x30,
    0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x04,
    0x46, 0x30, 0x44, 0x02, 0x20, 0x4a, 0x12, 0xf8, 0xd4, 0x2f, 0x90, 0x23,
    0x5c, 0x05, 0xa7, 0x71, 0x21, 0xcb, 0xeb, 0xae, 0x15, 0xd5, 0x90, 0x14,
    0x65, 0x58, 0xe9, 0xc9, 0xb4, 0x7a, 0x1a, 0x38, 0xf7, 0xa3, 0x6a, 0x7d,
    0xc5, 0x02, 0x20, 0x20, 0xa4, 0x74, 0x28, 0x97, 0xc3, 0x0a, 0xed, 0xa0,
    0xa5, 0x6b, 0x36, 0xe1, 0x4e, 0xbb, 0xc8, 0x5b, 0xbd, 0xb7, 0x44, 0x93,
    0xf9, 0x93, 0x58, 0x1e, 0xb0, 0x44, 0x4e, 0xd6, 0xca, 0x94, 0x0b};

struct PaseContext {
  SHA256 contextHash;
};

int make_handshake_res(PaseContext *ctx, const uint8_t *req, int reqsize,
                       uint8_t *res) {
  res[0] = 0b1100101;
  res[1] = 0x6C;
  res[2] = 0x04;  // ver
  res[3] = 244;   // mtu
  res[4] = 0;
  res[5] = 5;  // window
  return 6;
}

int make_pbdkres(PaseContext *ctx, const uint8_t *req, int reqsize,
                 uint8_t *res) {
  const uint8_t *initiatorRandom = RANDOM;

  ctx->contextHash.update((uint8_t *)TT_CONTEXT_INIT,
                          strlen(TT_CONTEXT_INIT));

  int pos = 0;
  pos += btp_get_header_size(req);
  uint64_t sender = message_get_sender(req + pos);
  pos += message_get_header_size(req + pos);
  uint16_t exchangeId = message_get_proto_echange_id(req + pos);
  pos += message_get_pheader_size(req + pos);
  ctx->contextHash.update(&req[pos], reqsize - pos);

  while (pos < reqsize) {
    tag_info ti;
    pos += tlv_read_tag(req + pos, &ti);
    if (ti.tag == 1 && ti.data_ref) {
      initiatorRandom = ti.data_ref;
    }
  }

  // PBKDFParamResponse
  int l = 0;
  l += btp_write_header(res + l, 0, 1, 124);  // ack, seq, sz(dummy)
  l += message_write_header(res + l, 0, 1, sender);
  l += message_write_pheader(res + l, MSG_PROTO_OP_PBKD_RES, exchangeId,
                             MSG_PROTO_ID_SECURE, 0);
  pos = l;
  l += tlv_write_struct(res + l, 0, 0);  // pbkdfparamresp-struct
  l += tlv_write_str(res + l, 1, 1, initiatorRandom, 32);  // initiatorRandom
  l += tlv_write_str(res + l, 1, 2, RANDOM, 32);           // responderRandom
  l += tlv_write(res + l, 1, 3, (uint16_t)1);              // responderSessionId
  l += tlv_write_struct(res + l, 1, 4);                    // pbkdf_parameters
  l += tlv_write(res + l, 1, 1, (uint16_t)HMAC_ITER);      // iterations
  l += tlv_write_str(res + l, 1, 2, SALT, 16);             // salt
  l += tlv_write_eos(res + l);  // end of pbkdf_parameters
  l += tlv_write_eos(res + l);
  btp_write_header(res, 0, 1, l - 5);  // update payload size

  ctx->contextHash.update(&res[pos], l - pos);

  return l;
}

int write_hex_str(const uint8_t *buf, int len, uint8_t *out) {
  int p = 0;
  for (int i = 0; i < len; i++) {
    out[p++] = '0' + (buf[i] >> 4);
    if (out[p-1] > '9') {
        out[p-1] = out[p-1] - '0' + 'a'-10;
    }
    out[p++] = '0' + (buf[i] & 0xf);
    if (out[p-1] > '9') {
        out[p-1] = out[p-1] - '0' + 'a'-10;
    }
    if (i != len - 1) {
      out[p++] = ':';
    }
  }
  out[p] = 0;
  return p;
}

int make_pake2(PaseContext *ctx, const uint8_t *req, int reqsize,
               uint8_t *res) {
  int pos = 0;
  pos += btp_get_header_size(req);
  uint64_t sender = message_get_sender(req + pos);
  pos += message_get_header_size(req + pos);
  uint16_t exchangeId = message_get_proto_echange_id(req + pos);
  pos += message_get_pheader_size(req + pos);

  const uint8_t *pA = nullptr;
  int pA_len = 0;
  while (pos < reqsize) {
    tag_info ti;
    pos += tlv_read_tag(req + pos, &ti);
    if (ti.tag == 1 && ti.data_ref) {
      pA = ti.data_ref;
      pA_len = ti.val_or_len;
    }
  }

  uint8_t ttctx[32];
  ctx->contextHash.finish(ttctx);
  SHA256 tthash;
  dump("CtxHash", ttctx, sizeof(ttctx));

  uint64_t sz = sizeof(ttctx);
  tthash.update((uint8_t *)&sz, 8);  // TODO: byte order
  tthash.update(ttctx, sizeof(ttctx));

  uint32_t pin = PIN;
  uint8_t ws[80];
  uint8_t pinbuf[16];
  write_hex_str((const uint8_t *)&pin, 4, pinbuf);
  LOG.print("PIN:");
  LOG.println((char*)pinbuf);
  pbkdf2_sha256_hmac(pinbuf, 11, SALT, 16, HMAC_ITER, sizeof(ws),
                     ws);
  dump(" a", ws, 80);

  uint8_t cB[32], pB[65];
  size_t pB_len = 65, cB_len = 32;
  debug_calc_cb(&tthash, ws, pA, pA_len, pB, &pB_len, cB, &cB_len);

  int l = 0;
  l += btp_write_header(res + l, 0, 2, 0);  // ack, seq, sz(dummy)
  l += message_write_header(res + l, 0, 2, sender);
  l += message_write_pheader(res + l, MSG_PROTO_OP_PASE_PAKE2, exchangeId,
                             MSG_PROTO_ID_SECURE, 0);
  l += tlv_write_struct(res + l, 0, 0);           // pbkdfparamresp-struct
  l += tlv_write_str(res + l, 1, 1, pB, pB_len);  // pB
  l += tlv_write_str(res + l, 1, 2, cB, cB_len);  // cB
  l += tlv_write_eos(res + l);
  btp_write_header(res, 0, 1, l - 5);  // update payload size
  return l;
}

int make_status_report(PaseContext *ctx, const uint8_t *req, int reqsize,
                       uint8_t *res, uint16_t code, uint16_t vid, uint16_t pid,
                       uint16_t status) {
  int pos = 0;
  pos += btp_get_header_size(req);
  uint64_t sender = message_get_sender(req + pos);
  pos += message_get_header_size(req + pos);
  uint16_t exchangeId = message_get_proto_echange_id(req + pos);
  pos += message_get_pheader_size(req + pos);

  int l = 0;
  l += btp_write_header(res + l, 0, 3, 0);  // ack, seq, sz(dummy)
  l += message_write_header(res + l, 0, 3, sender);
  l += message_write_pheader(res + l, MSG_PROTO_OP_STATUS_REPORT, exchangeId,
                             MSG_PROTO_ID_SECURE, 0);
  tlv_write16(res + l, code);
  l += 2;
  tlv_write16(res + l, vid);
  l += 2;
  tlv_write16(res + l, pid);
  l += 2;
  tlv_write16(res + l, status);
  l += 2;
  btp_write_header(res, 0, 1, l - 5);  // update payload size
  return l;
}